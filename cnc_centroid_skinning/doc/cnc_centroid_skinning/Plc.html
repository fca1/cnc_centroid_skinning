<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>cnc_centroid_skinning.Plc API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cnc_centroid_skinning.Plc</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from dataclasses import dataclass
from enum import IntEnum, unique
import typing

from .cncSkinningInterface import CncSkinningInterface
# noinspection PyUnresolvedReferences
from System.Collections.Generic import List
# noinspection PyUnresolvedReferences
from System import Array, String, Char, Int32, Double, Int64, UInt64, UInt32


@unique
class BitType(IntEnum):
    Input = 0
    &#34;&#34;&#34;A PLC input bit&#34;&#34;&#34;
    Output = 1
    &#34;&#34;&#34;A PLC output bit&#34;&#34;&#34;
    Memory = 2
    &#34;&#34;&#34;A PLC memory bit&#34;&#34;&#34;


@unique
class ForceState(IntEnum):
    NotForced = 0
    &#34;&#34;&#34;The PLC bit (input/output/memory) is not forced. It is controlled by the PLC program logic.&#34;&#34;&#34;
    ForcedOn = 1
    &#34;&#34;&#34;The PLC bit (output/memory) is forced on/set. For input PLC bit types, this is the same as ForcedOff since inputs use the Inversion state to determine whether the input is forced on or off.&#34;&#34;&#34;
    ForcedOff = 2
    &#34;&#34;&#34;The PLC bit (output/memory) is forced off/reset. For input PLC bit types, this is the same as ForcedOn since inputs use the Inversion state to determine whether the input is forced on or off.&#34;&#34;&#34;


@unique
class InversionState(IntEnum):
    NotIverted = 0
    &#34;&#34;&#34;The    input is not inverted&#34;&#34;&#34;
    Inverted = 1
    &#34;&#34;&#34;The    input is inverted&#34;&#34;&#34;


class IOState(IntEnum):
    IO_LOGICAL_0 = 0
    &#34;&#34;&#34;Open or off&#34;&#34;&#34;
    IO_LOGICAL_1 = 1
    &#34;&#34;&#34;Closed or on&#34;&#34;&#34;
    IO_INDEX_OUT_OF_RANGE = 2
    &#34;&#34;&#34;Invalid bit index&#34;&#34;&#34;
    IO_STATE_UNKNOWN = 3
    &#34;&#34;&#34;State could not be determined&#34;&#34;&#34;


@dataclass
class IOMBit:
    type: BitType = BitType.Input
    &#34;&#34;&#34;A BitType enumeration &#34;&#34;&#34;
    number: int = 0
    &#34;&#34;&#34;Bit number. &#34;&#34;&#34;
    state: IOState = IOState.IO_LOGICAL_0
    &#34;&#34;&#34;The state of the bit, used when returning a watch list. &#34;&#34;&#34;
    vcpButton: object = None
    &#34;&#34;&#34;The VCP button object &#34;&#34;&#34;

    def _fill_skinning_iombit(self, insiom):
        &#34;&#34;&#34;
        :return:  CncSkinning.IOMBIT object
        &#34;&#34;&#34;
        insiom.type = self.type  # copy all fields
        insiom.number = self.number
        insiom.state = self.state
        insiom.vcpButton = self.vcpButton
        return insiom


class PLc:
    &#34;&#34;&#34; A class with functions related to PLC programming and state information&#34;&#34;&#34;
    def __init__(self, interface: CncSkinningInterface):
        self.interface = interface

    def getWatchList(self, bitList: typing.List[IOMBit]) -&gt; [typing.List[IOMBit], None]:
        &#34;&#34;&#34;:return:  the states of watched bits previosuly set by SetPlcWatchList &#34;&#34;&#34;
        rs = List[self.interface._skinning.plc.IOMBit]()  # don&#39;t use the constructor with parameters
        for iombit in bitList:  # fills ref List&lt; IOMBit &gt; bitList
            insiom = self.interface._skinning.plc.IOMBit()  # CncSkinning.IOMBIT object
            rs.Add(iombit._fill_skinning_iombit(insiom))
        success, lst_iombit = self.interface(&#39;plc.GetWatchList&#39;, rs, wo_rc=True)
        if success:
            lst_wrap = list()
            for iombit in lst_iombit:
                obj = IOMBit(type=iombit.type, number=iombit.number, state=iombit.state, vcpButton=iombit.vcpButton)
                lst_wrap.append(obj)
            return lst_wrap
        else:
            return None

    def setWatchList(self, bitList: typing.List[IOMBit]) -&gt; [typing.List[IOMBit], None]:
        &#34;&#34;&#34;Set the PLC watch list. This command also returns with the current state of the bits updated in the bitList.
        When repeated calls using the same list occur, make an initial call to SetWatchList and then retrieve the states
        using GetWatchList. &#34;&#34;&#34;
        rs = List[self.interface._skinning.plc.IOMBit]()  # don&#39;t use the constructor with parameters
        for iombit in bitList:  # fills ref List&lt; IOMBit &gt; bitList
            insiom = self.interface._skinning.plc.IOMBit()  # CncSkinning.IOMBIT object
            rs.Add(iombit._fill_skinning_iombit(insiom))
        success, lst_iombit = self.interface(&#39;plc.SetWatchList&#39;, rs, wo_rc=True)
        if success:
            lst_wrap = list()
            for iombit in lst_iombit:
                obj = IOMBit(type=iombit.type, number=iombit.number, state=iombit.state, vcpButton=iombit.vcpButton)
                lst_wrap.append(obj)
            return lst_wrap
        else:
            return None

    def setIoForceState(self, ioBit: int, bitType: BitType, state: ForceState):
        &#34;&#34;&#34;Set the state of output or memory bit forcing. Note that for memory bit types, the forcing occurs at the
        beginning of a PLC program IOMpass only, i.e., PLC code can still change the state of the memory bit if desired. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetIoForceState&#39;, int(ioBit), bitType.value, state.value)

    def setSkinningDataWord(self, index: int, value: int, sendImmediately: bool = True):
        &#34;&#34;&#34;Set a skinning data word. A skinning data word is a general purpose 32-bit integer value used to communicate
         with a PLC program. A PLC program can reference this value using the SV_SKINNING_DATA_W_1 -
         SV_SKINNING_DATA_W_12 system variables. &#34;&#34;&#34;
        assert 1 &lt;= index &lt;= 12
        return self.interface(&#39;plc.SetSkinningDataWord&#39;, int(index), int(value), bool(sendImmediately))

    def getSkinningDataWord(self, index: int) -&gt; int:
        &#34;&#34;&#34;:return: the value of a skinning data word. &#34;&#34;&#34;
        assert 1 &lt;= index &lt;= 12
        return self.interface(&#39;plc.GetSkinningDataWord&#39;, int(index), 0)

    def setSkinningDataDoubleFloatWord(self, index: int, value: float, sendImmediately: bool = True):
        &#34;&#34;&#34;Set a skinning data float word. A skinning data float word is a general purpose 32-bit floating point value
        used to communicate with a PLC program. A PLC program can reference this value using the SV_SKINNING_DATA_FW_1
        - SV_SKINNING_DATA_FW_11 system variables. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetSkinningDataDoubleFloatWord&#39;, int(index), float(value), bool(sendImmediately))

    def getSkinningDataDoubleFloatWord(self, index: int) -&gt; float:
        &#34;&#34;&#34;:return: the value of a skinning float word. &#34;&#34;&#34;
        return self.interface(&#39;plc.GetSkinningDataDoubleFloatWord&#39;, int(index), 0.0)

    def setInputIversionState(self, inputBit: int, state: InversionState):
        &#34;&#34;&#34;Set whether or not a PLC inpuit bit is inverted. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetInputIversionState&#39;, int(inputBit), state.value)

    def setInputForceState(self, inputBit: int, state: ForceState):
        &#34;&#34;&#34;Set whether or not an input is forced to a given state. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetInputForceState&#39;, int(inputBit), state.value)

    def getInputState(self, bitNumber: int) -&gt; bool:
        assert 1 &lt;= bitNumber &lt;= 1312
        &#34;&#34;&#34;:return: the state of the PLC input &#34;&#34;&#34;
        return self.interface(&#39;plc.GetInputState&#39;, int(bitNumber), wo_rc=True)

    def getOutputState(self, bitNumber: int) -&gt; bool:
        &#34;&#34;&#34;:return:  the state (On or Off) of a PLC output. &#34;&#34;&#34;
        assert 1 &lt;= bitNumber &lt;= 1312
        return self.interface(&#39;plc.GetOutputState&#39;, int(bitNumber), wo_rc=True)

    def getMemoryState(self, bitNumber: int) -&gt; bool:
        &#34;&#34;&#34;:return:  the state of a PLC memory bit. &#34;&#34;&#34;
        assert 1 &lt;= bitNumber &lt;= 1024
        return self.interface(&#39;plc.GetMemoryState&#39;, int(bitNumber), wo_rc=True)

    def getWordValue(self, index: int) -&gt; int:
        &#34;&#34;&#34;:return: s the value of the given PLC 32-bit integer W value. &#34;&#34;&#34;
        assert 1 &lt;= index &lt;= 22
        return self.interface(&#39;plc.GetDoubleWordValue&#39;, int(index), 0)

    def getDoubleWordValue(self, index: int) -&gt; int:
        assert 1 &lt;= index &lt;= 22
        return self.getWordValue(index)

    def getFloatWordValue(self, index: int) -&gt; float:
        &#34;&#34;&#34;:return: s the value of the given PLC 32-bit floating point FW value. &#34;&#34;&#34;
        assert 1 &lt;= index &lt;= 44
        return self.interface(&#39;plc.GetDoubleFloatWordValue&#39;, int(index), 0.0)

    def setSkinEventState(self, eventNumber: int, state: int):
        &#34;&#34;&#34;Set skin event number to a given state. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetSkinEventState&#39;, int(eventNumber), int(state))

    def getPcSystemVariableBit(self, bit: int) -&gt; IOState:
        &#34;&#34;&#34;:return:  the state of a &#34;PC&#34; system variable bit. A &#34;PC&#34; system varaible bit is, in most cases, set by the CNC
        softare running on the PC and used to communicate status to the MPU hardware, in particular the PLC system. &#34;&#34;&#34;
        return IOState(self.interface(&#39;plc.GetPcSystemVariableBit&#39;, int(bit), 0))

    def getPlcSystemVariableBit(self, bit: int) -&gt; IOState:
        &#34;&#34;&#34;:return:  the state of a &#34;PLC&#34; system variable bit. A &#34;PLC&#34; system varaible bit is, in most cases, set by the PLC
         program running on the MPU hardware and used to communicate status to the CNC software. &#34;&#34;&#34;
        return self.interface(&#39;plc.GetPlcSystemVariableBit&#39;, int(bit), 0)

    def getVcpLedStates(self) -&gt; int:
        &#34;&#34;&#34;:return: the state of output LEDs for the VCP all at once. &#34;&#34;&#34;
        return self.interface(&#39;plc.GetVcpLedStates&#39;, wo_rc=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cnc_centroid_skinning.Plc.BitType"><code class="flex name class">
<span>class <span class="ident">BitType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BitType(IntEnum):
    Input = 0
    &#34;&#34;&#34;A PLC input bit&#34;&#34;&#34;
    Output = 1
    &#34;&#34;&#34;A PLC output bit&#34;&#34;&#34;
    Memory = 2
    &#34;&#34;&#34;A PLC memory bit&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cnc_centroid_skinning.Plc.BitType.Input"><code class="name">var <span class="ident">Input</span></code></dt>
<dd>
<div class="desc"><p>A PLC input bit</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.BitType.Memory"><code class="name">var <span class="ident">Memory</span></code></dt>
<dd>
<div class="desc"><p>A PLC memory bit</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.BitType.Output"><code class="name">var <span class="ident">Output</span></code></dt>
<dd>
<div class="desc"><p>A PLC output bit</p></div>
</dd>
</dl>
</dd>
<dt id="cnc_centroid_skinning.Plc.ForceState"><code class="flex name class">
<span>class <span class="ident">ForceState</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForceState(IntEnum):
    NotForced = 0
    &#34;&#34;&#34;The PLC bit (input/output/memory) is not forced. It is controlled by the PLC program logic.&#34;&#34;&#34;
    ForcedOn = 1
    &#34;&#34;&#34;The PLC bit (output/memory) is forced on/set. For input PLC bit types, this is the same as ForcedOff since inputs use the Inversion state to determine whether the input is forced on or off.&#34;&#34;&#34;
    ForcedOff = 2
    &#34;&#34;&#34;The PLC bit (output/memory) is forced off/reset. For input PLC bit types, this is the same as ForcedOn since inputs use the Inversion state to determine whether the input is forced on or off.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cnc_centroid_skinning.Plc.ForceState.ForcedOff"><code class="name">var <span class="ident">ForcedOff</span></code></dt>
<dd>
<div class="desc"><p>The PLC bit (output/memory) is forced off/reset. For input PLC bit types, this is the same as ForcedOn since inputs use the Inversion state to determine whether the input is forced on or off.</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.ForceState.ForcedOn"><code class="name">var <span class="ident">ForcedOn</span></code></dt>
<dd>
<div class="desc"><p>The PLC bit (output/memory) is forced on/set. For input PLC bit types, this is the same as ForcedOff since inputs use the Inversion state to determine whether the input is forced on or off.</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.ForceState.NotForced"><code class="name">var <span class="ident">NotForced</span></code></dt>
<dd>
<div class="desc"><p>The PLC bit (input/output/memory) is not forced. It is controlled by the PLC program logic.</p></div>
</dd>
</dl>
</dd>
<dt id="cnc_centroid_skinning.Plc.IOMBit"><code class="flex name class">
<span>class <span class="ident">IOMBit</span></span>
<span>(</span><span>type: <a title="cnc_centroid_skinning.Plc.BitType" href="#cnc_centroid_skinning.Plc.BitType">BitType</a> = BitType.Input, number: int = 0, state: <a title="cnc_centroid_skinning.Plc.IOState" href="#cnc_centroid_skinning.Plc.IOState">IOState</a> = IOState.IO_LOGICAL_0, vcpButton: object = None)</span>
</code></dt>
<dd>
<div class="desc"><p>IOMBit(type: cnc_centroid_skinning.Plc.BitType = <BitType.Input: 0>, number: int = 0, state: cnc_centroid_skinning.Plc.IOState = <IOState.IO_LOGICAL_0: 0>, vcpButton: object = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IOMBit:
    type: BitType = BitType.Input
    &#34;&#34;&#34;A BitType enumeration &#34;&#34;&#34;
    number: int = 0
    &#34;&#34;&#34;Bit number. &#34;&#34;&#34;
    state: IOState = IOState.IO_LOGICAL_0
    &#34;&#34;&#34;The state of the bit, used when returning a watch list. &#34;&#34;&#34;
    vcpButton: object = None
    &#34;&#34;&#34;The VCP button object &#34;&#34;&#34;

    def _fill_skinning_iombit(self, insiom):
        &#34;&#34;&#34;
        :return:  CncSkinning.IOMBIT object
        &#34;&#34;&#34;
        insiom.type = self.type  # copy all fields
        insiom.number = self.number
        insiom.state = self.state
        insiom.vcpButton = self.vcpButton
        return insiom</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="cnc_centroid_skinning.Plc.IOMBit.number"><code class="name">var <span class="ident">number</span> : int</code></dt>
<dd>
<div class="desc"><p>Bit number.</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.IOMBit.state"><code class="name">var <span class="ident">state</span> : <a title="cnc_centroid_skinning.Plc.IOState" href="#cnc_centroid_skinning.Plc.IOState">IOState</a></code></dt>
<dd>
<div class="desc"><p>The state of the bit, used when returning a watch list.</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.IOMBit.type"><code class="name">var <span class="ident">type</span> : <a title="cnc_centroid_skinning.Plc.BitType" href="#cnc_centroid_skinning.Plc.BitType">BitType</a></code></dt>
<dd>
<div class="desc"><p>A BitType enumeration</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.IOMBit.vcpButton"><code class="name">var <span class="ident">vcpButton</span> : object</code></dt>
<dd>
<div class="desc"><p>The VCP button object</p></div>
</dd>
</dl>
</dd>
<dt id="cnc_centroid_skinning.Plc.IOState"><code class="flex name class">
<span>class <span class="ident">IOState</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IOState(IntEnum):
    IO_LOGICAL_0 = 0
    &#34;&#34;&#34;Open or off&#34;&#34;&#34;
    IO_LOGICAL_1 = 1
    &#34;&#34;&#34;Closed or on&#34;&#34;&#34;
    IO_INDEX_OUT_OF_RANGE = 2
    &#34;&#34;&#34;Invalid bit index&#34;&#34;&#34;
    IO_STATE_UNKNOWN = 3
    &#34;&#34;&#34;State could not be determined&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cnc_centroid_skinning.Plc.IOState.IO_INDEX_OUT_OF_RANGE"><code class="name">var <span class="ident">IO_INDEX_OUT_OF_RANGE</span></code></dt>
<dd>
<div class="desc"><p>Invalid bit index</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.IOState.IO_LOGICAL_0"><code class="name">var <span class="ident">IO_LOGICAL_0</span></code></dt>
<dd>
<div class="desc"><p>Open or off</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.IOState.IO_LOGICAL_1"><code class="name">var <span class="ident">IO_LOGICAL_1</span></code></dt>
<dd>
<div class="desc"><p>Closed or on</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.IOState.IO_STATE_UNKNOWN"><code class="name">var <span class="ident">IO_STATE_UNKNOWN</span></code></dt>
<dd>
<div class="desc"><p>State could not be determined</p></div>
</dd>
</dl>
</dd>
<dt id="cnc_centroid_skinning.Plc.InversionState"><code class="flex name class">
<span>class <span class="ident">InversionState</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InversionState(IntEnum):
    NotIverted = 0
    &#34;&#34;&#34;The    input is not inverted&#34;&#34;&#34;
    Inverted = 1
    &#34;&#34;&#34;The    input is inverted&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cnc_centroid_skinning.Plc.InversionState.Inverted"><code class="name">var <span class="ident">Inverted</span></code></dt>
<dd>
<div class="desc"><p>The
input is inverted</p></div>
</dd>
<dt id="cnc_centroid_skinning.Plc.InversionState.NotIverted"><code class="name">var <span class="ident">NotIverted</span></code></dt>
<dd>
<div class="desc"><p>The
input is not inverted</p></div>
</dd>
</dl>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc"><code class="flex name class">
<span>class <span class="ident">PLc</span></span>
<span>(</span><span>interface: <a title="cnc_centroid_skinning.cncSkinningInterface.CncSkinningInterface" href="cncSkinningInterface.html#cnc_centroid_skinning.cncSkinningInterface.CncSkinningInterface">CncSkinningInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A class with functions related to PLC programming and state information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PLc:
    &#34;&#34;&#34; A class with functions related to PLC programming and state information&#34;&#34;&#34;
    def __init__(self, interface: CncSkinningInterface):
        self.interface = interface

    def getWatchList(self, bitList: typing.List[IOMBit]) -&gt; [typing.List[IOMBit], None]:
        &#34;&#34;&#34;:return:  the states of watched bits previosuly set by SetPlcWatchList &#34;&#34;&#34;
        rs = List[self.interface._skinning.plc.IOMBit]()  # don&#39;t use the constructor with parameters
        for iombit in bitList:  # fills ref List&lt; IOMBit &gt; bitList
            insiom = self.interface._skinning.plc.IOMBit()  # CncSkinning.IOMBIT object
            rs.Add(iombit._fill_skinning_iombit(insiom))
        success, lst_iombit = self.interface(&#39;plc.GetWatchList&#39;, rs, wo_rc=True)
        if success:
            lst_wrap = list()
            for iombit in lst_iombit:
                obj = IOMBit(type=iombit.type, number=iombit.number, state=iombit.state, vcpButton=iombit.vcpButton)
                lst_wrap.append(obj)
            return lst_wrap
        else:
            return None

    def setWatchList(self, bitList: typing.List[IOMBit]) -&gt; [typing.List[IOMBit], None]:
        &#34;&#34;&#34;Set the PLC watch list. This command also returns with the current state of the bits updated in the bitList.
        When repeated calls using the same list occur, make an initial call to SetWatchList and then retrieve the states
        using GetWatchList. &#34;&#34;&#34;
        rs = List[self.interface._skinning.plc.IOMBit]()  # don&#39;t use the constructor with parameters
        for iombit in bitList:  # fills ref List&lt; IOMBit &gt; bitList
            insiom = self.interface._skinning.plc.IOMBit()  # CncSkinning.IOMBIT object
            rs.Add(iombit._fill_skinning_iombit(insiom))
        success, lst_iombit = self.interface(&#39;plc.SetWatchList&#39;, rs, wo_rc=True)
        if success:
            lst_wrap = list()
            for iombit in lst_iombit:
                obj = IOMBit(type=iombit.type, number=iombit.number, state=iombit.state, vcpButton=iombit.vcpButton)
                lst_wrap.append(obj)
            return lst_wrap
        else:
            return None

    def setIoForceState(self, ioBit: int, bitType: BitType, state: ForceState):
        &#34;&#34;&#34;Set the state of output or memory bit forcing. Note that for memory bit types, the forcing occurs at the
        beginning of a PLC program IOMpass only, i.e., PLC code can still change the state of the memory bit if desired. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetIoForceState&#39;, int(ioBit), bitType.value, state.value)

    def setSkinningDataWord(self, index: int, value: int, sendImmediately: bool = True):
        &#34;&#34;&#34;Set a skinning data word. A skinning data word is a general purpose 32-bit integer value used to communicate
         with a PLC program. A PLC program can reference this value using the SV_SKINNING_DATA_W_1 -
         SV_SKINNING_DATA_W_12 system variables. &#34;&#34;&#34;
        assert 1 &lt;= index &lt;= 12
        return self.interface(&#39;plc.SetSkinningDataWord&#39;, int(index), int(value), bool(sendImmediately))

    def getSkinningDataWord(self, index: int) -&gt; int:
        &#34;&#34;&#34;:return: the value of a skinning data word. &#34;&#34;&#34;
        assert 1 &lt;= index &lt;= 12
        return self.interface(&#39;plc.GetSkinningDataWord&#39;, int(index), 0)

    def setSkinningDataDoubleFloatWord(self, index: int, value: float, sendImmediately: bool = True):
        &#34;&#34;&#34;Set a skinning data float word. A skinning data float word is a general purpose 32-bit floating point value
        used to communicate with a PLC program. A PLC program can reference this value using the SV_SKINNING_DATA_FW_1
        - SV_SKINNING_DATA_FW_11 system variables. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetSkinningDataDoubleFloatWord&#39;, int(index), float(value), bool(sendImmediately))

    def getSkinningDataDoubleFloatWord(self, index: int) -&gt; float:
        &#34;&#34;&#34;:return: the value of a skinning float word. &#34;&#34;&#34;
        return self.interface(&#39;plc.GetSkinningDataDoubleFloatWord&#39;, int(index), 0.0)

    def setInputIversionState(self, inputBit: int, state: InversionState):
        &#34;&#34;&#34;Set whether or not a PLC inpuit bit is inverted. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetInputIversionState&#39;, int(inputBit), state.value)

    def setInputForceState(self, inputBit: int, state: ForceState):
        &#34;&#34;&#34;Set whether or not an input is forced to a given state. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetInputForceState&#39;, int(inputBit), state.value)

    def getInputState(self, bitNumber: int) -&gt; bool:
        assert 1 &lt;= bitNumber &lt;= 1312
        &#34;&#34;&#34;:return: the state of the PLC input &#34;&#34;&#34;
        return self.interface(&#39;plc.GetInputState&#39;, int(bitNumber), wo_rc=True)

    def getOutputState(self, bitNumber: int) -&gt; bool:
        &#34;&#34;&#34;:return:  the state (On or Off) of a PLC output. &#34;&#34;&#34;
        assert 1 &lt;= bitNumber &lt;= 1312
        return self.interface(&#39;plc.GetOutputState&#39;, int(bitNumber), wo_rc=True)

    def getMemoryState(self, bitNumber: int) -&gt; bool:
        &#34;&#34;&#34;:return:  the state of a PLC memory bit. &#34;&#34;&#34;
        assert 1 &lt;= bitNumber &lt;= 1024
        return self.interface(&#39;plc.GetMemoryState&#39;, int(bitNumber), wo_rc=True)

    def getWordValue(self, index: int) -&gt; int:
        &#34;&#34;&#34;:return: s the value of the given PLC 32-bit integer W value. &#34;&#34;&#34;
        assert 1 &lt;= index &lt;= 22
        return self.interface(&#39;plc.GetDoubleWordValue&#39;, int(index), 0)

    def getDoubleWordValue(self, index: int) -&gt; int:
        assert 1 &lt;= index &lt;= 22
        return self.getWordValue(index)

    def getFloatWordValue(self, index: int) -&gt; float:
        &#34;&#34;&#34;:return: s the value of the given PLC 32-bit floating point FW value. &#34;&#34;&#34;
        assert 1 &lt;= index &lt;= 44
        return self.interface(&#39;plc.GetDoubleFloatWordValue&#39;, int(index), 0.0)

    def setSkinEventState(self, eventNumber: int, state: int):
        &#34;&#34;&#34;Set skin event number to a given state. &#34;&#34;&#34;
        return self.interface(&#39;plc.SetSkinEventState&#39;, int(eventNumber), int(state))

    def getPcSystemVariableBit(self, bit: int) -&gt; IOState:
        &#34;&#34;&#34;:return:  the state of a &#34;PC&#34; system variable bit. A &#34;PC&#34; system varaible bit is, in most cases, set by the CNC
        softare running on the PC and used to communicate status to the MPU hardware, in particular the PLC system. &#34;&#34;&#34;
        return IOState(self.interface(&#39;plc.GetPcSystemVariableBit&#39;, int(bit), 0))

    def getPlcSystemVariableBit(self, bit: int) -&gt; IOState:
        &#34;&#34;&#34;:return:  the state of a &#34;PLC&#34; system variable bit. A &#34;PLC&#34; system varaible bit is, in most cases, set by the PLC
         program running on the MPU hardware and used to communicate status to the CNC software. &#34;&#34;&#34;
        return self.interface(&#39;plc.GetPlcSystemVariableBit&#39;, int(bit), 0)

    def getVcpLedStates(self) -&gt; int:
        &#34;&#34;&#34;:return: the state of output LEDs for the VCP all at once. &#34;&#34;&#34;
        return self.interface(&#39;plc.GetVcpLedStates&#39;, wo_rc=True)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cnc_centroid_skinning.Plc.PLc.getDoubleWordValue"><code class="name flex">
<span>def <span class="ident">getDoubleWordValue</span></span>(<span>self, index: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDoubleWordValue(self, index: int) -&gt; int:
    assert 1 &lt;= index &lt;= 22
    return self.getWordValue(index)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getFloatWordValue"><code class="name flex">
<span>def <span class="ident">getFloatWordValue</span></span>(<span>self, index: int) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: s the value of the given PLC 32-bit floating point FW value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFloatWordValue(self, index: int) -&gt; float:
    &#34;&#34;&#34;:return: s the value of the given PLC 32-bit floating point FW value. &#34;&#34;&#34;
    assert 1 &lt;= index &lt;= 44
    return self.interface(&#39;plc.GetDoubleFloatWordValue&#39;, int(index), 0.0)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getInputState"><code class="name flex">
<span>def <span class="ident">getInputState</span></span>(<span>self, bitNumber: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInputState(self, bitNumber: int) -&gt; bool:
    assert 1 &lt;= bitNumber &lt;= 1312
    &#34;&#34;&#34;:return: the state of the PLC input &#34;&#34;&#34;
    return self.interface(&#39;plc.GetInputState&#39;, int(bitNumber), wo_rc=True)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getMemoryState"><code class="name flex">
<span>def <span class="ident">getMemoryState</span></span>(<span>self, bitNumber: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return:
the state of a PLC memory bit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMemoryState(self, bitNumber: int) -&gt; bool:
    &#34;&#34;&#34;:return:  the state of a PLC memory bit. &#34;&#34;&#34;
    assert 1 &lt;= bitNumber &lt;= 1024
    return self.interface(&#39;plc.GetMemoryState&#39;, int(bitNumber), wo_rc=True)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getOutputState"><code class="name flex">
<span>def <span class="ident">getOutputState</span></span>(<span>self, bitNumber: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return:
the state (On or Off) of a PLC output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOutputState(self, bitNumber: int) -&gt; bool:
    &#34;&#34;&#34;:return:  the state (On or Off) of a PLC output. &#34;&#34;&#34;
    assert 1 &lt;= bitNumber &lt;= 1312
    return self.interface(&#39;plc.GetOutputState&#39;, int(bitNumber), wo_rc=True)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getPcSystemVariableBit"><code class="name flex">
<span>def <span class="ident">getPcSystemVariableBit</span></span>(<span>self, bit: int) ‑> <a title="cnc_centroid_skinning.Plc.IOState" href="#cnc_centroid_skinning.Plc.IOState">IOState</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return:
the state of a "PC" system variable bit. A "PC" system varaible bit is, in most cases, set by the CNC
softare running on the PC and used to communicate status to the MPU hardware, in particular the PLC system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPcSystemVariableBit(self, bit: int) -&gt; IOState:
    &#34;&#34;&#34;:return:  the state of a &#34;PC&#34; system variable bit. A &#34;PC&#34; system varaible bit is, in most cases, set by the CNC
    softare running on the PC and used to communicate status to the MPU hardware, in particular the PLC system. &#34;&#34;&#34;
    return IOState(self.interface(&#39;plc.GetPcSystemVariableBit&#39;, int(bit), 0))</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getPlcSystemVariableBit"><code class="name flex">
<span>def <span class="ident">getPlcSystemVariableBit</span></span>(<span>self, bit: int) ‑> <a title="cnc_centroid_skinning.Plc.IOState" href="#cnc_centroid_skinning.Plc.IOState">IOState</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return:
the state of a "PLC" system variable bit. A "PLC" system varaible bit is, in most cases, set by the PLC
program running on the MPU hardware and used to communicate status to the CNC software.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPlcSystemVariableBit(self, bit: int) -&gt; IOState:
    &#34;&#34;&#34;:return:  the state of a &#34;PLC&#34; system variable bit. A &#34;PLC&#34; system varaible bit is, in most cases, set by the PLC
     program running on the MPU hardware and used to communicate status to the CNC software. &#34;&#34;&#34;
    return self.interface(&#39;plc.GetPlcSystemVariableBit&#39;, int(bit), 0)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getSkinningDataDoubleFloatWord"><code class="name flex">
<span>def <span class="ident">getSkinningDataDoubleFloatWord</span></span>(<span>self, index: int) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the value of a skinning float word.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSkinningDataDoubleFloatWord(self, index: int) -&gt; float:
    &#34;&#34;&#34;:return: the value of a skinning float word. &#34;&#34;&#34;
    return self.interface(&#39;plc.GetSkinningDataDoubleFloatWord&#39;, int(index), 0.0)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getSkinningDataWord"><code class="name flex">
<span>def <span class="ident">getSkinningDataWord</span></span>(<span>self, index: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the value of a skinning data word.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSkinningDataWord(self, index: int) -&gt; int:
    &#34;&#34;&#34;:return: the value of a skinning data word. &#34;&#34;&#34;
    assert 1 &lt;= index &lt;= 12
    return self.interface(&#39;plc.GetSkinningDataWord&#39;, int(index), 0)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getVcpLedStates"><code class="name flex">
<span>def <span class="ident">getVcpLedStates</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the state of output LEDs for the VCP all at once.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVcpLedStates(self) -&gt; int:
    &#34;&#34;&#34;:return: the state of output LEDs for the VCP all at once. &#34;&#34;&#34;
    return self.interface(&#39;plc.GetVcpLedStates&#39;, wo_rc=True)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getWatchList"><code class="name flex">
<span>def <span class="ident">getWatchList</span></span>(<span>self, bitList: List[<a title="cnc_centroid_skinning.Plc.IOMBit" href="#cnc_centroid_skinning.Plc.IOMBit">IOMBit</a>]) ‑> [typing.List[<a title="cnc_centroid_skinning.Plc.IOMBit" href="#cnc_centroid_skinning.Plc.IOMBit">IOMBit</a>], None]</span>
</code></dt>
<dd>
<div class="desc"><p>:return:
the states of watched bits previosuly set by SetPlcWatchList</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWatchList(self, bitList: typing.List[IOMBit]) -&gt; [typing.List[IOMBit], None]:
    &#34;&#34;&#34;:return:  the states of watched bits previosuly set by SetPlcWatchList &#34;&#34;&#34;
    rs = List[self.interface._skinning.plc.IOMBit]()  # don&#39;t use the constructor with parameters
    for iombit in bitList:  # fills ref List&lt; IOMBit &gt; bitList
        insiom = self.interface._skinning.plc.IOMBit()  # CncSkinning.IOMBIT object
        rs.Add(iombit._fill_skinning_iombit(insiom))
    success, lst_iombit = self.interface(&#39;plc.GetWatchList&#39;, rs, wo_rc=True)
    if success:
        lst_wrap = list()
        for iombit in lst_iombit:
            obj = IOMBit(type=iombit.type, number=iombit.number, state=iombit.state, vcpButton=iombit.vcpButton)
            lst_wrap.append(obj)
        return lst_wrap
    else:
        return None</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.getWordValue"><code class="name flex">
<span>def <span class="ident">getWordValue</span></span>(<span>self, index: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>:return: s the value of the given PLC 32-bit integer W value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWordValue(self, index: int) -&gt; int:
    &#34;&#34;&#34;:return: s the value of the given PLC 32-bit integer W value. &#34;&#34;&#34;
    assert 1 &lt;= index &lt;= 22
    return self.interface(&#39;plc.GetDoubleWordValue&#39;, int(index), 0)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.setInputForceState"><code class="name flex">
<span>def <span class="ident">setInputForceState</span></span>(<span>self, inputBit: int, state: <a title="cnc_centroid_skinning.Plc.ForceState" href="#cnc_centroid_skinning.Plc.ForceState">ForceState</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set whether or not an input is forced to a given state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInputForceState(self, inputBit: int, state: ForceState):
    &#34;&#34;&#34;Set whether or not an input is forced to a given state. &#34;&#34;&#34;
    return self.interface(&#39;plc.SetInputForceState&#39;, int(inputBit), state.value)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.setInputIversionState"><code class="name flex">
<span>def <span class="ident">setInputIversionState</span></span>(<span>self, inputBit: int, state: <a title="cnc_centroid_skinning.Plc.InversionState" href="#cnc_centroid_skinning.Plc.InversionState">InversionState</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set whether or not a PLC inpuit bit is inverted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInputIversionState(self, inputBit: int, state: InversionState):
    &#34;&#34;&#34;Set whether or not a PLC inpuit bit is inverted. &#34;&#34;&#34;
    return self.interface(&#39;plc.SetInputIversionState&#39;, int(inputBit), state.value)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.setIoForceState"><code class="name flex">
<span>def <span class="ident">setIoForceState</span></span>(<span>self, ioBit: int, bitType: <a title="cnc_centroid_skinning.Plc.BitType" href="#cnc_centroid_skinning.Plc.BitType">BitType</a>, state: <a title="cnc_centroid_skinning.Plc.ForceState" href="#cnc_centroid_skinning.Plc.ForceState">ForceState</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the state of output or memory bit forcing. Note that for memory bit types, the forcing occurs at the
beginning of a PLC program IOMpass only, i.e., PLC code can still change the state of the memory bit if desired.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setIoForceState(self, ioBit: int, bitType: BitType, state: ForceState):
    &#34;&#34;&#34;Set the state of output or memory bit forcing. Note that for memory bit types, the forcing occurs at the
    beginning of a PLC program IOMpass only, i.e., PLC code can still change the state of the memory bit if desired. &#34;&#34;&#34;
    return self.interface(&#39;plc.SetIoForceState&#39;, int(ioBit), bitType.value, state.value)</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.setSkinEventState"><code class="name flex">
<span>def <span class="ident">setSkinEventState</span></span>(<span>self, eventNumber: int, state: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set skin event number to a given state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSkinEventState(self, eventNumber: int, state: int):
    &#34;&#34;&#34;Set skin event number to a given state. &#34;&#34;&#34;
    return self.interface(&#39;plc.SetSkinEventState&#39;, int(eventNumber), int(state))</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.setSkinningDataDoubleFloatWord"><code class="name flex">
<span>def <span class="ident">setSkinningDataDoubleFloatWord</span></span>(<span>self, index: int, value: float, sendImmediately: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a skinning data float word. A skinning data float word is a general purpose 32-bit floating point value
used to communicate with a PLC program. A PLC program can reference this value using the SV_SKINNING_DATA_FW_1
- SV_SKINNING_DATA_FW_11 system variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSkinningDataDoubleFloatWord(self, index: int, value: float, sendImmediately: bool = True):
    &#34;&#34;&#34;Set a skinning data float word. A skinning data float word is a general purpose 32-bit floating point value
    used to communicate with a PLC program. A PLC program can reference this value using the SV_SKINNING_DATA_FW_1
    - SV_SKINNING_DATA_FW_11 system variables. &#34;&#34;&#34;
    return self.interface(&#39;plc.SetSkinningDataDoubleFloatWord&#39;, int(index), float(value), bool(sendImmediately))</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.setSkinningDataWord"><code class="name flex">
<span>def <span class="ident">setSkinningDataWord</span></span>(<span>self, index: int, value: int, sendImmediately: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a skinning data word. A skinning data word is a general purpose 32-bit integer value used to communicate
with a PLC program. A PLC program can reference this value using the SV_SKINNING_DATA_W_1 -
SV_SKINNING_DATA_W_12 system variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSkinningDataWord(self, index: int, value: int, sendImmediately: bool = True):
    &#34;&#34;&#34;Set a skinning data word. A skinning data word is a general purpose 32-bit integer value used to communicate
     with a PLC program. A PLC program can reference this value using the SV_SKINNING_DATA_W_1 -
     SV_SKINNING_DATA_W_12 system variables. &#34;&#34;&#34;
    assert 1 &lt;= index &lt;= 12
    return self.interface(&#39;plc.SetSkinningDataWord&#39;, int(index), int(value), bool(sendImmediately))</code></pre>
</details>
</dd>
<dt id="cnc_centroid_skinning.Plc.PLc.setWatchList"><code class="name flex">
<span>def <span class="ident">setWatchList</span></span>(<span>self, bitList: List[<a title="cnc_centroid_skinning.Plc.IOMBit" href="#cnc_centroid_skinning.Plc.IOMBit">IOMBit</a>]) ‑> [typing.List[<a title="cnc_centroid_skinning.Plc.IOMBit" href="#cnc_centroid_skinning.Plc.IOMBit">IOMBit</a>], None]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the PLC watch list. This command also returns with the current state of the bits updated in the bitList.
When repeated calls using the same list occur, make an initial call to SetWatchList and then retrieve the states
using GetWatchList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setWatchList(self, bitList: typing.List[IOMBit]) -&gt; [typing.List[IOMBit], None]:
    &#34;&#34;&#34;Set the PLC watch list. This command also returns with the current state of the bits updated in the bitList.
    When repeated calls using the same list occur, make an initial call to SetWatchList and then retrieve the states
    using GetWatchList. &#34;&#34;&#34;
    rs = List[self.interface._skinning.plc.IOMBit]()  # don&#39;t use the constructor with parameters
    for iombit in bitList:  # fills ref List&lt; IOMBit &gt; bitList
        insiom = self.interface._skinning.plc.IOMBit()  # CncSkinning.IOMBIT object
        rs.Add(iombit._fill_skinning_iombit(insiom))
    success, lst_iombit = self.interface(&#39;plc.SetWatchList&#39;, rs, wo_rc=True)
    if success:
        lst_wrap = list()
        for iombit in lst_iombit:
            obj = IOMBit(type=iombit.type, number=iombit.number, state=iombit.state, vcpButton=iombit.vcpButton)
            lst_wrap.append(obj)
        return lst_wrap
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cnc_centroid_skinning" href="index.html">cnc_centroid_skinning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cnc_centroid_skinning.Plc.BitType" href="#cnc_centroid_skinning.Plc.BitType">BitType</a></code></h4>
<ul class="">
<li><code><a title="cnc_centroid_skinning.Plc.BitType.Input" href="#cnc_centroid_skinning.Plc.BitType.Input">Input</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.BitType.Memory" href="#cnc_centroid_skinning.Plc.BitType.Memory">Memory</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.BitType.Output" href="#cnc_centroid_skinning.Plc.BitType.Output">Output</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnc_centroid_skinning.Plc.ForceState" href="#cnc_centroid_skinning.Plc.ForceState">ForceState</a></code></h4>
<ul class="">
<li><code><a title="cnc_centroid_skinning.Plc.ForceState.ForcedOff" href="#cnc_centroid_skinning.Plc.ForceState.ForcedOff">ForcedOff</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.ForceState.ForcedOn" href="#cnc_centroid_skinning.Plc.ForceState.ForcedOn">ForcedOn</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.ForceState.NotForced" href="#cnc_centroid_skinning.Plc.ForceState.NotForced">NotForced</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnc_centroid_skinning.Plc.IOMBit" href="#cnc_centroid_skinning.Plc.IOMBit">IOMBit</a></code></h4>
<ul class="">
<li><code><a title="cnc_centroid_skinning.Plc.IOMBit.number" href="#cnc_centroid_skinning.Plc.IOMBit.number">number</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.IOMBit.state" href="#cnc_centroid_skinning.Plc.IOMBit.state">state</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.IOMBit.type" href="#cnc_centroid_skinning.Plc.IOMBit.type">type</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.IOMBit.vcpButton" href="#cnc_centroid_skinning.Plc.IOMBit.vcpButton">vcpButton</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnc_centroid_skinning.Plc.IOState" href="#cnc_centroid_skinning.Plc.IOState">IOState</a></code></h4>
<ul class="">
<li><code><a title="cnc_centroid_skinning.Plc.IOState.IO_INDEX_OUT_OF_RANGE" href="#cnc_centroid_skinning.Plc.IOState.IO_INDEX_OUT_OF_RANGE">IO_INDEX_OUT_OF_RANGE</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.IOState.IO_LOGICAL_0" href="#cnc_centroid_skinning.Plc.IOState.IO_LOGICAL_0">IO_LOGICAL_0</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.IOState.IO_LOGICAL_1" href="#cnc_centroid_skinning.Plc.IOState.IO_LOGICAL_1">IO_LOGICAL_1</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.IOState.IO_STATE_UNKNOWN" href="#cnc_centroid_skinning.Plc.IOState.IO_STATE_UNKNOWN">IO_STATE_UNKNOWN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnc_centroid_skinning.Plc.InversionState" href="#cnc_centroid_skinning.Plc.InversionState">InversionState</a></code></h4>
<ul class="">
<li><code><a title="cnc_centroid_skinning.Plc.InversionState.Inverted" href="#cnc_centroid_skinning.Plc.InversionState.Inverted">Inverted</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.InversionState.NotIverted" href="#cnc_centroid_skinning.Plc.InversionState.NotIverted">NotIverted</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnc_centroid_skinning.Plc.PLc" href="#cnc_centroid_skinning.Plc.PLc">PLc</a></code></h4>
<ul class="">
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getDoubleWordValue" href="#cnc_centroid_skinning.Plc.PLc.getDoubleWordValue">getDoubleWordValue</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getFloatWordValue" href="#cnc_centroid_skinning.Plc.PLc.getFloatWordValue">getFloatWordValue</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getInputState" href="#cnc_centroid_skinning.Plc.PLc.getInputState">getInputState</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getMemoryState" href="#cnc_centroid_skinning.Plc.PLc.getMemoryState">getMemoryState</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getOutputState" href="#cnc_centroid_skinning.Plc.PLc.getOutputState">getOutputState</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getPcSystemVariableBit" href="#cnc_centroid_skinning.Plc.PLc.getPcSystemVariableBit">getPcSystemVariableBit</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getPlcSystemVariableBit" href="#cnc_centroid_skinning.Plc.PLc.getPlcSystemVariableBit">getPlcSystemVariableBit</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getSkinningDataDoubleFloatWord" href="#cnc_centroid_skinning.Plc.PLc.getSkinningDataDoubleFloatWord">getSkinningDataDoubleFloatWord</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getSkinningDataWord" href="#cnc_centroid_skinning.Plc.PLc.getSkinningDataWord">getSkinningDataWord</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getVcpLedStates" href="#cnc_centroid_skinning.Plc.PLc.getVcpLedStates">getVcpLedStates</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getWatchList" href="#cnc_centroid_skinning.Plc.PLc.getWatchList">getWatchList</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.getWordValue" href="#cnc_centroid_skinning.Plc.PLc.getWordValue">getWordValue</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.setInputForceState" href="#cnc_centroid_skinning.Plc.PLc.setInputForceState">setInputForceState</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.setInputIversionState" href="#cnc_centroid_skinning.Plc.PLc.setInputIversionState">setInputIversionState</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.setIoForceState" href="#cnc_centroid_skinning.Plc.PLc.setIoForceState">setIoForceState</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.setSkinEventState" href="#cnc_centroid_skinning.Plc.PLc.setSkinEventState">setSkinEventState</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.setSkinningDataDoubleFloatWord" href="#cnc_centroid_skinning.Plc.PLc.setSkinningDataDoubleFloatWord">setSkinningDataDoubleFloatWord</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.setSkinningDataWord" href="#cnc_centroid_skinning.Plc.PLc.setSkinningDataWord">setSkinningDataWord</a></code></li>
<li><code><a title="cnc_centroid_skinning.Plc.PLc.setWatchList" href="#cnc_centroid_skinning.Plc.PLc.setWatchList">setWatchList</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>